#include <stdlib.h>// Для calloc и free
#include <assert.h>// Для assert.h
#include "Desk.h"
#include "new.h"

void* new(const void* _class, Desk* desk, ...)  {// Реализация функции new
	const struct Class* class = _class;// Пребразуем тип переданного указателя. Хотя он и объявлен как void* (в целях сокрытия данных о классе), мы-то знаем, что это struct Class*.

	// Выделяем память. Стандартная функция calloc обычно используется для создания массивов. Её первый аргумент — размер массива, второй — размер
	// ячейки массива. После выделения соответствующего количества памяти она зануляет эту память и возвращает указатель.
	void* p = calloc(1, class->size);
	assert(p);// Проверка на то, что память выделилась

	// Прописывание класса объекта. Все объекты в системе устроены так, что в самых первых байтах памяти, выделенной под объект, содержится указатель на
	// глобальную структуру типа Class, описывающую класс этого объекта. Здесь этот указатель лежит в переменной class. p как раз указывает на то место, куда должен лечь class.
	*(const struct Class**)p = class;
	if (class->ctor) {// Если задан конструктор...
		va_list ap;
		// Инициализируем работу с переменными аргументами. После выполнения va_start ap будет указывать на следующий аргумент после _class,
		// то есть первый аргумент, который должен достаться функции-конструктору.
		va_start(ap, desk);
		p = class->ctor(p, desk, &ap);// Вызываем конструктор    
		va_end(ap);// Очищаем ap
	}
	return p; // Возвращаем указатель на объект
}

void delete(void* self){// Реализация функции delete
	const struct Class** cp = self;// Поскольку нам потребуется доступ к описанию класса объекта, сделаем удобное преобразование типов    
	if (self && *cp && (*cp)->dtor)// Проверка деструктора. *cp получает указатель на struct Class, из которой достаём поле dtor        
		self = (*cp)->dtor(self);// Если деструктор задан, вызываем его. Он должен вернуть указатель на исходный блок памяти    
	free(self);// Освобождаем выделенный блок памяти
}

void attack(const void* self, Desk* desk) {
	const struct Class* const* cp = self;
	assert(self && *cp && (*cp)->attack);
	(*cp)->attack(self, desk);
}